/*******************************************************************************
 * Copyright (c) 2012, Jean-David Gadina <macmade@eosgarden.com>
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id$ */

/*!
 * @file            ...
 * @author          Jean-David Gadina <macmade@eosgarden>
 * @copyright       (c) 2012, eosgarden
 * @abstract        ...
 */

/*******************************************************************************
 * Copyright notice:
 * 
 * This file is based AsyncSocket project, originally created by Dustin Voss,
 * updated and maintained by Deusty Designs and the Mac development community.
 * 
 * The original project is placed in the public domain, and available
 * in GitHub: https://github.com/robbiehanson/CocoaAsyncSocket
 ******************************************************************************/

#import <netinet/in.h>
#import <arpa/inet.h>
#import <netdb.h>
#import "EOSSocket.h"
#import "EOSSocket+Private.h"

NSString * const EOSSocketException = @"EOSSocketException";

static NSLock * __lock = nil;

@implementation EOSSocket

@synthesize delegate        = _delegate;
@synthesize CFReadStream    = _CFReadStream;
@synthesize CFWriteStream   = _CFWriteStream;
@synthesize flags           = _flags;

+ ( void )initialize
{
    __lock = [ NSLock new ];
}

- ( id )init
{
    if( ( self = [ super init ] ) )
    {}
    
    return self;
}

- ( CFSocketRef )CFSocket
{
    @synchronized( self )
    {
        return ( _ipv4Socket != NULL ) ? _ipv4Socket : _ipv6Socket;
    }
}

- ( BOOL )acceptOnPort: ( NSUInteger )port error: ( NSError ** )error
{
    return [ self acceptOnAddress: nil port: port error: error ];
}

- ( BOOL )acceptOnAddress: ( NSString * )address port: ( NSUInteger )port error: ( NSError ** )error
{
    struct sockaddr_in  ipv4Address;
    struct sockaddr_in6 ipv6Address;
    struct sockaddr   * sockAddressIPV4;
    struct sockaddr   * sockAddressIPV6;
    
    sockAddressIPV4 = NULL;
    sockAddressIPV6 = NULL;
    
    if( error != NULL )
    {
        *( error ) = nil;
    }
    
    if( _delegate == nil )
    {
        @throw [ NSException exceptionWithName: EOSSocketException reason: @"A delegate is required" userInfo: nil ];
    }
    
    if( _ipv4Socket != NULL || _ipv6Socket != NULL )
    {
        @throw [ NSException exceptionWithName: EOSSocketException reason: @"Socket is already connected" userInfo: nil ];
    }
    
    if( address == nil || address.length == 0 )
    {
        ipv4Address.sin_len         = sizeof( struct sockaddr_in );
        ipv4Address.sin_family      = AF_INET;
        ipv4Address.sin_port        = htons( port );
        ipv4Address.sin_addr.s_addr = htonl( INADDR_ANY );
        ipv6Address.sin6_len        = sizeof( struct sockaddr_in6 );
        ipv6Address.sin6_family     = AF_INET6;
        ipv6Address.sin6_port       = htons( port );
        ipv6Address.sin6_flowinfo   = 0;
        ipv6Address.sin6_addr       = in6addr_any;
        ipv6Address.sin6_scope_id   = 0;
        
        memset( &( ipv4Address.sin_zero ), 0, sizeof( ipv4Address.sin_zero ) );
    }
    else if( [ [ address lowercaseString ] isEqualToString: @"localhost" ] || [ [ address lowercaseString ] isEqualToString: @"loopback" ] )
    {
        ipv4Address.sin_len         = sizeof( struct sockaddr_in );
        ipv4Address.sin_family      = AF_INET;
        ipv4Address.sin_port        = htons( port );
        ipv4Address.sin_addr.s_addr = htonl( INADDR_LOOPBACK );
        ipv6Address.sin6_len        = sizeof( struct sockaddr_in6 );
        ipv6Address.sin6_family     = AF_INET6;
        ipv6Address.sin6_port       = htons( port );
        ipv6Address.sin6_flowinfo   = 0;
        ipv6Address.sin6_addr       = in6addr_loopback;
        ipv6Address.sin6_scope_id   = 0;
        
        memset( &( ipv4Address.sin_zero ), 0, sizeof( ipv4Address.sin_zero ) );
    }
    else
    {
        {
            const char      * portCString;
            const char      * hostCString;
            int               status;
            struct addrinfo   info;
            struct addrinfo * infoRes;
            struct addrinfo * infoResPtr;
            
            [ __lock lock ];
            
            portCString = [ [ NSString stringWithFormat: @"%u", port ] cStringUsingEncoding: NSASCIIStringEncoding ];
            hostCString = [ address cStringUsingEncoding: NSASCIIStringEncoding ];
            
            memset( &info, 0, sizeof( struct addrinfo ) );
            
            info.ai_family      = PF_UNSPEC;
            info.ai_socktype    = SOCK_STREAM;
            info.ai_protocol    = IPPROTO_TCP;
            info.ai_flags       = AI_PASSIVE;
            
            status = getaddrinfo( hostCString, portCString, &info, &infoRes );
            
            if( status != 0 )
            {
                if( error != NULL )
                {
                    *( error ) = [ NSError
                                    errorWithDomain:    @"POSIX.getaddrinfo"
                                    code:               status
                                    userInfo:           nil
                                 ];
                }
                
                [ __lock unlock ];
                
                return NO;
            }
            
            infoResPtr = infoRes;
            
            while( infoResPtr != NULL )
            {
                if( sockAddressIPV4 == NULL && infoResPtr->ai_family == AF_INET )
                {
                    sockAddressIPV4 = infoResPtr->ai_addr;
                }
                else if( sockAddressIPV6 == NULL && infoResPtr->ai_family == AF_INET6 )
                {
                    sockAddressIPV6 = infoResPtr->ai_addr;
                }
                
                infoResPtr = infoResPtr->ai_next;
            }
            
            freeaddrinfo( infoRes );
            
            if( sockAddressIPV4 == NULL || sockAddressIPV6 == NULL )
            {
                [ __lock unlock ];
                
                return NO;
            }
            
            [ __lock unlock ];
        }
    }
    
    if( sockAddressIPV4 != NULL )
    {
        _ipv4Socket = [ self createAcceptSocketForAddress: sockAddressIPV4 error: error ];
        
        if( _ipv4Socket == NULL )
        {
            if( error != NULL && *( error ) == nil )
            {
                *( error ) = [ NSError errorWithDomain: @"EOSSocketError" code: EOSSocketErrorCFSocket userInfo: nil ];
            }
            
            if( _ipv4Socket != NULL )
            {
                CFSocketInvalidate( _ipv4Socket );
                CFRelease( _ipv4Socket );
                
                _ipv4Socket = NULL;
            }
            
            if( _ipv6Socket != NULL )
            {
                CFSocketInvalidate( _ipv6Socket );
                CFRelease( _ipv6Socket );
                
                _ipv6Socket = NULL;
            }
            
            return NO;
        }
    }
    
    if( sockAddressIPV6 != NULL )
    {
        _ipv6Socket = [ self createAcceptSocketForAddress: sockAddressIPV6 error: error ];
        
        /* iOS doesn't support IPv6 */
        #if !TARGET_OS_IPHONE
        
        if( _ipv6Socket == NULL )
        {
            if( error != NULL && *( error ) == nil )
            {
                *( error ) = [ NSError errorWithDomain: @"EOSSocketError" code: EOSSocketErrorCFSocket userInfo: nil ];
            }
            
            if( _ipv4Socket != NULL )
            {
                CFSocketInvalidate( _ipv4Socket );
                CFRelease( _ipv4Socket );
                
                _ipv4Socket = NULL;
            }
            
            if( _ipv6Socket != NULL )
            {
                CFSocketInvalidate( _ipv6Socket );
                CFRelease( _ipv6Socket );
                
                _ipv6Socket = NULL;
            }
            
            return NO;
        }
        
        #endif
    }
    
	[ self attachSocketsToRunLoop: nil error: nil ];
	
	// Set the SO_REUSEADDR flags.
	/*
	int reuseOn = 1;
	if (theSocket)	setsockopt(CFSocketGetNative(theSocket), SOL_SOCKET, SO_REUSEADDR, &reuseOn, sizeof(reuseOn));
	if (theSocket6)	setsockopt(CFSocketGetNative(theSocket6), SOL_SOCKET, SO_REUSEADDR, &reuseOn, sizeof(reuseOn));
	
	// Set the local bindings which causes the sockets to start listening.
	
	CFSocketError err;
	if (theSocket)
	{
		err = CFSocketSetAddress (theSocket, (CFDataRef)address);
		if (err != kCFSocketSuccess) goto Failed;
		
		//NSLog(@"theSocket4: %hu", [self localPort:theSocket]);
	}
	
	if(port == 0 && theSocket && theSocket6)
	{
		// The user has passed in port 0, which means he wants to allow the kernel to choose the port for them
		// However, the kernel will choose a different port for both theSocket and theSocket6
		// So we grab the port the kernel choose for theSocket, and set it as the port for theSocket6
		UInt16 chosenPort = [self localPort:theSocket];
		
		struct sockaddr_in6 *pSockAddr6 = (struct sockaddr_in6 *)[address6 bytes];
		//pSockAddr6->sin6_port = htons(chosenPort);
        
        if( pSockAddr6 != NULL )
        {
            pSockAddr6->sin6_port = htons(chosenPort);
        }
    }
	
	if (theSocket6)
	{
		err = CFSocketSetAddress (theSocket6, (CFDataRef)address6);
		if (err != kCFSocketSuccess) goto Failed;
		
		//NSLog(@"theSocket6: %hu", [self localPort:theSocket6]);
	}
	*/
	_flags |= EOSSocketFlagsConnected;
    
	return YES;
}

- ( BOOL )connectToHost: ( NSString * )host port: ( NSUInteger )port error: ( NSError ** )error
{
    if( error != NULL )
    {
        *( error ) = nil;
    }
    
    ( void )host;
    ( void )port;
    
    return NO;
}

- ( BOOL )connectToAddress: ( struct sockaddr * )address error: ( NSError ** )error
{
    if( error != NULL )
    {
        *( error ) = nil;
    }
    
    ( void )address;
    
    return NO;
}

- ( void )disconnect
{}

- ( void )disconnectAfterWriting
{}

- ( BOOL )connected
{
    @synchronized( self )
    {
        return NO;
    }
}

- ( BOOL )ipv4
{
    @synchronized( self )
    {
        return NO;
    }
}

- ( BOOL )ipv6
{
    @synchronized( self )
    {
        return NO;
    }
}

- ( NSString * )localHost
{
    @synchronized( self )
    {
        return nil;
    }
}

- ( NSUInteger )localPort
{
    @synchronized( self )
    {
        return 0;
    }
}

- ( NSString * )remoteHost
{
    @synchronized( self )
    {
        return nil;
    }
}

- ( NSUInteger )remotePort
{
    @synchronized( self )
    {
        return 0;
    }
}

@end
